<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Jennifer Daniel</title>

<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=DynaPuff:wdth,wght@75..100,400..700&family=Noto+Emoji:wght@300..700&family=Poppins:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&display=swap" rel="stylesheet">

<link rel="stylesheet" type="text/css" href="styles.css">

<style>

</style>
</head>
<body class="">


<main class="container link-container">
  <canvas id="emojiCanvas"></canvas>
  <h3 id="unicode" class="link">Unicode</h3>
  <h3 class="link" id="emojiKitchen">Emoji Kitchen</h3>
  <h3 class="link" id="googleEmoji">Google Emoji</h3>
  <h3 class="link" id="noto">Noto Emoji</h3>
  <h3 id="nyt" class="link">New York Times</h3>
  <h3 id="editorial" class="link">Editorial</h3>

  <div class="controls">
    <h4>Noto Emoji</h4>
    <p>Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod
    tempor incididunt ut labore et dolore magna aliqua.</p>

    <div class="toggles">
      <div class="emojiToggle" data-emoji="ğŸ¢">ğŸ¢</div>
      <div class="emojiToggle" data-emoji="ğŸ’–">ğŸ’–</div>

      <div class="emojiToggle" data-emoji="ğŸ‰">ğŸ‰</div>
      <div class="emojiToggle" data-emoji="ğŸ•">ğŸ•</div>
      
      <div class="emojiToggle" data-emoji="ğŸ˜">ğŸ˜</div>
      <div class="emojiToggle" data-emoji="ğŸ›">ğŸ›</div>

      <div class="emojiToggle" data-emoji="ğŸ·">ğŸ·</div>
      <div class="emojiToggle" data-emoji="ğŸ¶">ğŸ¶</div>

      <div class="emojiToggle" data-emoji="ğŸ¥³">ğŸ¥³</div>
      <div class="emojiToggle" data-emoji="ğŸ˜˜">ğŸ˜˜</div>

          <div class="emojiToggle" data-emoji="ğŸ™‚â€â†•ï¸">ğŸ™‚â€â†•ï¸</div>
      <div class="emojiToggle" data-emoji="ğŸ« ">ğŸ« </div>



      
    </div>
  </div>
</main>

<script type="text/javascript">
const DEFAULT_SHOW_INTERVAL = 50;
let showInterval = DEFAULT_SHOW_INTERVAL;
let intervalId = null;
let activeState = null
let startTimestamp;
let animationFrameId;
const emojis = ["ğŸ¢", "ğŸ’•", "ğŸ•", "ğŸ›", "ğŸ·", "ğŸ¶", "ğŸ¥³", "ğŸ‰", "ğŸ« ", "ğŸ™‚â€â†•ï¸"];

const getRandomEmojis = (arr, n) => {
  const s = [...arr].sort(() => Math.random() - 0.5);
  return n > arr.length ? s : s.slice(0, n);
};


const canvas = document.getElementById("emojiCanvas");
const ctx = canvas.getContext("2d");

let renderedEmojis = []

// ids and timestamps for all the stickers
const stickers = [];
const clearEverything = (target, newState) => {
  if(activeState === null || activeState != newState){
    cleanupGoogle()
    cleanup()
    cleanupNoto()
    resetLinks(target)
  }
  activeState = newState;
}

const showEmojiKitchenSticker = () => {
  const w = window.innerWidth; // Use innerWidth for viewport size
  const h = window.innerHeight;
  const size = Math.random() * 400; // Adjust sticker size
  const x = Math.random() * (w - size);
  const y = Math.random() * (h - size);
  const randomImage = Math.floor(Math.random() * 61);

  let img = document.createElement('img');
  img.src = `images/stickers/image_${randomImage}.png`; // Use the image source from the array
  img.className = (Math.random() > .5) ? 'sticker' : 'sticker negative';

  img.style.left = `${x}px`; // Use pixels for positioning with viewport size
  img.style.top = `${y}px`;
  img.style.width = `${size}px`;
  img.style.height = `${size}px`;

  // set id might not be unique but its fine...
  const imgId = Date.now();
  img.id = imgId;

  document.body.appendChild(img);
  stickers.push(imgId)
};

const startShowing = (e) => {
  
  clearInterval(intervalId); // Clear any existing interval
  showInterval = DEFAULT_SHOW_INTERVAL; // Reset interval on new hover
  intervalId = setInterval(() => {

    showEmojiKitchenSticker();
    showEmojiKitchenSticker();

    if (showInterval > 50) {
      showInterval -= 10;
    } else if (showInterval < 2) {
        showInterval = 2; // Prevent interval from going too low
    }
    clearInterval(intervalId); // Clear and reset with new interval
    intervalId = setInterval(startShowing, showInterval); // Call startShowing again with updated interval
  }, showInterval);
};

const cleanup = () => {
  clearInterval(intervalId); // Stop the interval when mouse leaves
  intervalId = null
  const stickerElements = document.getElementsByClassName('sticker');
  // Remove in reverse order to avoid index issues
  for (let i = stickerElements.length - 1; i >= 0; i--) {
    stickerElements[i].remove();
  }
};

const triggerEmoji = document.getElementById('emojiKitchen');
triggerEmoji.addEventListener('click', (e) => {
  clearEverything(e.target, 'emojiKitchen')
  startShowing()
});


/////////////////////////////////////////////
// emoji

const resetLinks = (target, newActiveState) => {
  console.log(target)
  let activeLink = document.getElementsByClassName('active')[0]
  if(activeLink){
    activeLink.classList.remove('active')
  }
  target.classList.add('active')
  activeState = newActiveState
}

const startShowingGoogle = () => {

  clearInterval(intervalId); // Clear any existing interval
  showInterval = (intervalId === null) ? 0 : 1000; // Reset interval on new hover
  intervalId = setInterval(() => {

    showGoogleEmoji();
    showGoogleEmoji();
    showGoogleEmoji();
    showGoogleEmoji();
    // showEmojiKitchenSticker();
    if (showInterval > 50) {
      showInterval -= 10;
    } else if (showInterval < 2) {
        showInterval = 2; // Prevent interval from going too low
    }
    clearInterval(intervalId); // Clear and reset with new interval
    intervalId = setInterval(startShowingGoogle, showInterval); // Call startShowing again with updated interval
  }, showInterval);
};


const showGoogleEmoji = () => {
  const w = window.innerWidth; // Use innerWidth for viewport size
  const h = window.innerHeight;
  const size = Math.random() * 400; // Adjust sticker size
  const x = Math.random() * (w - size);
  const y = h;
  const randomImage = Math.floor(Math.random() * 81);

  let img = document.createElement('img');
  img.src = `images/animated/${randomImage}.webp`; // Use the image source from the array
  // console.log('hi 2', img.src)
  img.className = 'googleEmoji';
  img.style.left = `${x}px`; // Use pixels for positioning with viewport size
  img.style.top = `${y}px`;
  img.style.width = `${size}px`;
  img.style.height = `${size}px`;
  img.id = `img-${Math.round(Math.random() * 10000)}`
  
  setTimeout(()=> {
    const el = document.getElementById(img.id)
    if(el){
      el.remove()
    }
  }, 10000)

  // set id might not be unique but its fine...
  const imgId = Date.now();
  img.id = imgId;

  document.body.appendChild(img);
  stickers.push(imgId)
};

const cleanupGoogle = () => {
  clearInterval(intervalId); // Stop the interval when mouse leaves
  intervalId = null
  const emojiElements = document.getElementsByClassName('googleEmoji');
  // Remove in reverse order to avoid index issues
  for (let i = emojiElements.length - 1; i >= 0; i--) {
    emojiElements[i].remove();
  }
};

const triggerGoogleEmoji = document.getElementById('googleEmoji');
triggerGoogleEmoji.addEventListener('click', (e) => {
  clearEverything(e.target, 'google')
  startShowingGoogle()
});



//////////////////////////////////////////////////////
// noto
//////////////////////////////////////////////////////
const random = () => {
  if (random.seed) {
    var x = Math.sin(random.seed++) * 10000;
    return x - Math.floor(x);
  }
  return Math.random();
}

// // List of emojis to use
// const emojis = ["ğŸ˜€", "ğŸ‰", "ğŸ”¥", "ğŸš€", "ğŸŒˆ", "ğŸ±", "ğŸŒŸ", "ğŸ•", "ğŸ¦„", "ğŸ¸"];

// Poisson Disk Sampling (Bridson's Algorithm)
function poissonDiskSampling(width, height, radius, k = 30) {
  console.log('disc')
    const gridSize = radius / Math.sqrt(2);
    const cols = Math.ceil(width / gridSize);
    const rows = Math.ceil(height / gridSize);
    const grid = Array(cols * rows).fill(null);
    const active = [];
    const points = [];

    function toGrid(x, y) {
        return [Math.floor(x / gridSize), Math.floor(y / gridSize)];
    }

    function inBounds(x, y) {
        return x >= 0 && y >= 0 && x < width && y < height;
    }

    function isFarEnough(x, y) {
        const [gx, gy] = toGrid(x, y);
        for (let i = -2; i <= 2; i++) {
            for (let j = -2; j <= 2; j++) {
                const nx = gx + i, ny = gy + j;
                if (nx >= 0 && ny >= 0 && nx < cols && ny < rows) {
                    const idx = nx + ny * cols;
                    const p = grid[idx];
                    if (p) {
                        const dx = p.x - x, dy = p.y - y;
                        if (dx * dx + dy * dy < radius * radius) return false;
                    }
                }
            }
        }
        return true;
    }

    function addPoint(x, y) {
        const [gx, gy] = toGrid(x, y);
        const idx = gx + gy * cols;
        grid[idx] = { x, y };
        points.push({ x, y });
        active.push({ x, y });
    }

    addPoint(Math.random() * width, Math.random() * height);

    while (active.length > 0) {
        const randIndex = Math.floor(Math.random() * active.length);
        const point = active[randIndex];
        let placed = false;

        for (let i = 0; i < k; i++) {
            const angle = Math.random() * Math.PI * 2;
            const r = radius * (1 + Math.random() * 0.5);
            const newX = point.x + Math.cos(angle) * r;
            const newY = point.y + Math.sin(angle) * r;

            if (inBounds(newX, newY) && isFarEnough(newX, newY)) {
                addPoint(newX, newY);
                placed = true;
                break;
            }
        }

        if (!placed) active.splice(randIndex, 1);
    }

    return points;
}





const showNoto = (e) => {
  console.log('noto called')
  renderedEmojis.length = 0;

  // Ensure crisp rendering by accounting for devicePixelRatio
  const dpr = window.devicePixelRatio || 1;
  canvas.width = window.innerWidth * dpr;
  canvas.height = window.innerHeight * dpr;
  ctx.scale(dpr, dpr); // Scale drawing to match high-resolution canvas

  ctx.fillStyle = "#000B24"
  ctx.fillRect(0, 0, canvas.width, canvas.height)

  // List of emojis to use
  

  
  const emojiSize = Math.min(canvas.width, canvas.height) * 0.015; 
  const radius = emojiSize * 2.5; // Ensure slight spacing

  // Get Poisson Disk points
  const points = poissonDiskSampling(canvas.width / dpr, canvas.height / dpr, radius);

  // Draw emojis
  
  ctx.textBaseline = "middle";
  ctx.textAlign = "center";
  ctx.fillStyle = "#A4A7D4";

  let emojiSet = getRandomEmojis(emojis, 3)
  console.log(emojiSet)

  points.forEach(({ x, y }) => {
    const emoji = emojiSet[Math.floor(Math.random() * emojiSet.length)];
    ctx.fillText(emoji, x, y);
    ctx.font = `200 ${emojiSize}px "Noto Emoji"`;


    renderedEmojis.push({
      x: x,
      y: y,
      scale: 1,
      emoji: emoji
    })
  })
}


const onMouseMove = (event) => {
  const canvas = document.getElementById("emojiCanvas");
  const ctx = canvas.getContext("2d");

  const { clientX: mouseX, clientY: mouseY } = event;
  if (!animationFrameId) {
      animationFrameId = requestAnimationFrame(() => {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        renderedEmojis.forEach((emoji) => {
          const centerX = emoji.x + 5;
          const centerY = emoji.y + 5;
          const dx = centerX - mouseX;
          const dy = centerY - mouseY;
          const distance = Math.sqrt(dx * dx + dy * dy);

          const maxScale = 3.4;
          const minScale = 1;
          const falloff = 100;
          const scale = minScale + (maxScale - minScale) * Math.exp(-distance / falloff);

          emoji.scale = scale;
          const emojiSize = Math.min(canvas.width, canvas.height) * 0.015;

          ctx.font = `200 ${emojiSize * emoji.scale}px "Noto Emoji"`;
          ctx.fillText(emoji.emoji, emoji.x, emoji.y);
        });

        animationFrameId = null; // Reset for the next frame
    });
  }
}


const triggerNoto = document.getElementById('noto');

triggerNoto.addEventListener('click', (e) => { 
  
  clearEverything(e.target, 'noto')
  

  

  

  document.body.addEventListener('mousemove',onMouseMove);
  
  showNoto()

}); 

const cleanupNoto = () => {
  let canvas = document.getElementById('emojiCanvas')
  let ctx = canvas.getContext('2d')
  ctx.clearRect(0, 0, canvas.width, canvas.height)

  console.log('cleanup')
  document.body.className = ''
  renderedEmojis = []
  
  document.body.removeEventListener('mousemove', onMouseMove)

  cancelAnimationFrame(animationFrameId)
  
  
};




</script>



</body>
</html>
